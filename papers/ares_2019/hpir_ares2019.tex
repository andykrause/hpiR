\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdftitle={hpiR: A software package for House Price Indexes},
            pdfauthor={Andy Krause -- Zillow Group -- Seattle, WA},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\usepackage{longtable,booktabs}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\newcommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}

  \title{hpiR: A software package for House Price Indexes}
    \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
    \author{Andy Krause -- Zillow Group -- Seattle, WA}
    \preauthor{\centering\large\emph}
  \postauthor{\par}
      \predate{\centering\large\emph}
  \postdate{\par}
    \date{2019-02-20}


\begin{document}
\maketitle

\subsubsection{Abstract}\label{abstract}

Real estate price indexes are widely used across many different property
types, use cases and research designs. This paper is divided into two
parts. In the first, I provide an overview of the recently released open
source package, \textbf{hpiR}, (R language) for calculating house price
indexes. I also cover the development of a consistent terminology such
as well as presenting key functionality of the package such as
calculating price index accuracy, volatility and revision statistics. In
the second part of the paper I present a new approach to house price
index construction -- the use of random forest simulations -- and
compare this new method with established repeat sales and hedonic model
methodologies.

\subsection{Part 1: Concepts and
Functionality}\label{part-1-concepts-and-functionality}

\subsubsection{Introduction}\label{introduction}

This vignette provides an introduction to using the \texttt{hpiR}
package for estimating house price indexes. At the current time, this
package (version 0.2.0) offers two approaches to estimate house price
indexes -- repeat transactions and hedonic price models. Future versions
will incorporate additional methodological options.

\paragraph{Additional Resources}\label{additional-resources}

More information on this package's development can be found at
\href{https://www.github.com/andykrause/hpiR}{www.github.com/andykrause/hpiR}.

The official CRAN repository page is located at:
\url{https://cran.r-project.org/web/packages/hpiR/index.html}

A detailed explanation of the class and method structure employed in
this package can be found in the \textbf{Classes in hpiR} vignette in
this package, or at:
\url{https://cran.r-project.org/web/packages/hpiR/vignettes/classstructure.html}

\paragraph{Terminology}\label{terminology}

A bit of terminology:

\begin{itemize}
\tightlist
\item
  \textbf{Index}: a time-series of values estimating tracking the
  movement of prices over time with a base period value of 100
\item
  \textbf{Series}: progression of increasing longer indexes\\
\item
  \textbf{Model}: statistical or other type of mathematical equation or
  algorithm used to generate the raw coefficient (or other) estimates
  that are converted into the scaled (base = 100) index values
\item
  \textbf{Accuracy}: ability of an index to represent the actual market
  movements
\item
  \textbf{Volatility}: measure of the period to period movement in index
  values
\item
  \textbf{Smooth}: reduce volatility with a rolling average or similar
  smoothing process
\item
  \textbf{Revision}: amount that the index value for a specific period
  moves over the course of a \textbf{series}
\end{itemize}

In general, this vignette takes the following path through the
functionality provided by \texttt{hpiR} as this is imagined to most
closely approximate a real-world application of the package to real
estate market data.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Data preparation}
\item
  \textbf{Modeling}
\item
  \textbf{Index creation}
\item
  \textbf{Analysis: Index-level}
\item
  \textbf{Series creation}
\item
  \textbf{Analysis: Series-level}
\end{enumerate}

\subsubsection{Load Package}\label{load-package}

Begin by loading the \texttt{hpiR} packages (assuming that you've
already downloaded it from:
\href{https://www.github.com/andykrause/hpiR}{www.github.com/andykrause/hpiR}
or from CRAN (forthcoming).

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{library}\NormalTok{(hpiR)}
\end{Highlighting}
\end{Shaded}

\subsubsection{Data}\label{data}

This package provides two sample datasets to work with. The first,
\texttt{seattle\_sales}, includes over 43,000 sales of single family
homes and townhouses within the City of Seattle over the 2010 to 2016
time frame. The second, \texttt{ex\_sales} is a subset of the first,
encompassing only the central area of the city. The source of the data
is the King County Assessor's office.\footnote{A small amount of data
  cleaning has gone into the creating the data, for more information on
  this process please contact the author.} The data is open and free to
share.

The data can be loaded with the \texttt{data(seattle\_sales)} and
\texttt{data(ex\_sales)} commands. We will work with the
\texttt{ex\_sales} object in this vignette.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{data}\NormalTok{(seattle_sales)}

  \KeywordTok{data}\NormalTok{(ex_sales)}
\end{Highlighting}
\end{Shaded}

All potential models, indexes and series that can be created with
\texttt{hpiR} require the transaction date to be converted to a numeric
and relative time period. Relative, here, means relative to the base
period which is assumed to be the first period in the transaction data.

The \texttt{dateToPeriod()} function will convert R date fields into
relative time periods based on a periodicity of choice. The available
periodicity options are:

\begin{itemize}
\tightlist
\item
  \emph{``yearly''}
\item
  \emph{``quarterly''}
\item
  \emph{``monthly''}
\item
  \emph{``weekly''}
\end{itemize}

with \emph{``yearly''} as the default. In addition to the transaction
data (\texttt{trans\_df}) and the period type selection
(\texttt{periodicity}), the \texttt{dateToPeriod()} function also
requires an input telling it which field in the data contains the
transaction date (\texttt{date}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  sales_hdf <-}\StringTok{ }\KeywordTok{dateToPeriod}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ ex_sales,}
                            \DataTypeTok{date =} \StringTok{'sale_date'}\NormalTok{,}
                            \DataTypeTok{periodicity =} \StringTok{'monthly'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The default specification of \texttt{dateToPeriod()} will use the
minimum and maximum dates in the data provided to it as the lower and
upper time boundaries for the modeling and index creation that follow.
You can, however, set custom dates using the \texttt{min\_date} and
\texttt{max\_date} arguments. For example, let's assume that we want to
estimate an index that covers the entire transaction period plus one
month on either side (in this case from December 2009 to January 2017).
We add these dates as alternate minimums and maximums. You see a warning
telling you that there are empty periods -- periods in which there are
no transactions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  sales_hdf <-}\StringTok{ }\KeywordTok{dateToPeriod}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ ex_sales,}
                            \DataTypeTok{date =} \StringTok{'sale_date'}\NormalTok{,}
                            \DataTypeTok{periodicity =} \StringTok{'monthly'}\NormalTok{,}
                            \DataTypeTok{min_date =} \KeywordTok{as.Date}\NormalTok{(}\StringTok{'2009-12-01'}\NormalTok{),}
                            \DataTypeTok{max_date =} \KeywordTok{as.Date}\NormalTok{(}\StringTok{'2016-12-31'}\NormalTok{))}
\NormalTok{## Your choice of periodicity resulted in 1 empty periods out of 85 total periods.}
\end{Highlighting}
\end{Shaded}

If the dates that are provided as alternative minimums and maximums are
within the range of transaction dates in the data, there are two options
to what can happen. The first, and default, is that the minimums and
maximums will be adjusted to be the actual minimum and maximum dates in
the transactions. A warning will let you know that this has happened.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  sales_hdf <-}\StringTok{ }\KeywordTok{dateToPeriod}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ ex_sales,}
                            \DataTypeTok{date =} \StringTok{'sale_date'}\NormalTok{,}
                            \DataTypeTok{periodicity =} \StringTok{'monthly'}\NormalTok{,}
                            \DataTypeTok{min_date =} \KeywordTok{as.Date}\NormalTok{(}\StringTok{'2010-12-01'}\NormalTok{),}
                            \DataTypeTok{max_date =} \KeywordTok{as.Date}\NormalTok{(}\StringTok{'2015-12-31'}\NormalTok{))}
\NormalTok{## Supplied "min_date" is greater than minimum of transactions. Adjusting.}
\NormalTok{## Supplied "max_date" is less than maximum of transactions. Adjusting.}
\end{Highlighting}
\end{Shaded}

Alternatively, you can use the \texttt{min\_date} and \texttt{max\_date}
arguments to ``clip''" your dataset to a particular time frame by
setting \texttt{adj\_type\ =\ "clip"}. The default,
\texttt{adj\_type\ =\ "move"}, simply moves it to the minimum or maximum
in the data as shown above. The clipping functionality allows you to
create an index for a subset of the time period covered by your data.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  sales_hdf_clip <-}\StringTok{ }\KeywordTok{dateToPeriod}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ ex_sales,}
                                 \DataTypeTok{date =} \StringTok{'sale_date'}\NormalTok{,}
                                 \DataTypeTok{periodicity =} \StringTok{'monthly'}\NormalTok{,}
                                 \DataTypeTok{min_date =} \KeywordTok{as.Date}\NormalTok{(}\StringTok{'2010-12-01'}\NormalTok{),}
                                 \DataTypeTok{max_date =} \KeywordTok{as.Date}\NormalTok{(}\StringTok{'2015-12-31'}\NormalTok{),}
                                 \DataTypeTok{adj_type =} \StringTok{'clip'}\NormalTok{)}
\NormalTok{## Supplied "min_date" date is greater than minimum of transactions. Clipping transactions.}
\NormalTok{## Supplied "max_date" is less than maximum of transactions. Clipping transactions.}
\end{Highlighting}
\end{Shaded}

For the sake of the remainder of this analysis, let's allow the defaults
to set the time boundaries based on the data itself (we will use the
\texttt{sales\_hdf} object going forward).

We now have a dataset that includes two new, standardized fields
(\texttt{trans\_date} and \texttt{trans\_period}) indicating the date of
transaction and the period of each transaction relative to the first
transaction in the data (at a monthly periodicity), respectively. Note
that these standardized fields are required for the processes that
follow.

Additional information on the full extent of the periods as well as
their numeric and date values can be found in the
\texttt{"period\_table"} attribute of the \texttt{sales\_hdf} object or
accessed by:

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{head}\NormalTok{(}\KeywordTok{attr}\NormalTok{(sales_hdf, }\StringTok{'period_table'}\NormalTok{))}
\NormalTok{##       name  numeric period}
\NormalTok{## 1 2010-Jan 2010.000      1}
\NormalTok{## 2 2010-Feb 2010.083      2}
\NormalTok{## 3 2010-Mar 2010.167      3}
\NormalTok{## 4 2010-Apr 2010.250      4}
\NormalTok{## 5 2010-May 2010.333      5}
\NormalTok{## 6 2010-Jun 2010.417      6}
\end{Highlighting}
\end{Shaded}

Finally, information on the minimum date, maximum date and the
periodicity can also be found in the attributes of \texttt{hpidata}
objects.

\subsubsection{Repeat Transactions (Sales)
Model}\label{repeat-transactions-sales-model}

Let's start by creating an index using a repeat-transactions model
(often referred to as a repeat-sales or a sale-resale model), one of the
most popular approaches to create a house price index.

\paragraph{Data Prep}\label{data-prep}

First, we use the \texttt{rtCreateTrans()} function to convert the
transaction data (the \texttt{hpidata} object) into a
\texttt{data.frame} of repeat transactions (properties that have
transacted multiple times in the 2010 to 2016 period.) The
\texttt{rtCreateTrans()} function requires a unique property id field, a
unique transaction id field and a field denoting the transaction price.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  sales_rtdf <-}\StringTok{ }\KeywordTok{rtCreateTrans}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ sales_hdf,}
                              \DataTypeTok{prop_id =} \StringTok{'pinx'}\NormalTok{,}
                              \DataTypeTok{trans_id =} \StringTok{'sale_id'}\NormalTok{,}
                              \DataTypeTok{price =} \StringTok{'sale_price'}\NormalTok{)}
                          
\end{Highlighting}
\end{Shaded}

This function creates a \texttt{data.frame} with eight fields: the
property id, the time period for the first transaction and the second
transaction, the prices for the two tranactions, the unique transaction
ids for both and a unique id for the pair. The resulting object has a
class of \texttt{rtdata} (inheriting from \texttt{hpidata} and
\texttt{data.frame}).

\begin{longtable}[]{@{}lrrrrllr@{}}
\toprule
prop\_id & period\_1 & period\_2 & price\_1 & price\_2 & trans\_id1 &
trans\_id2 & pair\_id\tabularnewline
\midrule
\endhead
..0007600057 & 56 & 80 & 520000 & 625000 & 2014..23738 & 2016..28612 &
1\tabularnewline
..0216000010 & 29 & 47 & 1063000 & 1300000 & 2012..12112 & 2013..36837 &
2\tabularnewline
..0342000250 & 40 & 78 & 626800 & 751000 & 2013..11548 & 2016..17781 &
3\tabularnewline
..0342000570 & 15 & 57 & 295000 & 429000 & 2011..4885 & 2014..27574 &
4\tabularnewline
..0342000570 & 15 & 78 & 295000 & 607000 & 2011..4885 & 2016..18557 &
5\tabularnewline
..0342000570 & 57 & 78 & 429000 & 607000 & 2014..27574 & 2016..18557 &
6\tabularnewline
\bottomrule
\end{longtable}

In the event of more than two transactions of the same property, all
pairs of transactions are created by default -- sales 1 to 2, 1 to 3 and
2 to 3. If you'd like to only use sequential transactions as pairs --
sales 1 to 2 and 2 to 3, for example -- you can set
\texttt{seq\_only\ =\ TRUE} (default is FALSE).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  sales_rtdf_so <-}\StringTok{ }\KeywordTok{rtCreateTrans}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ sales_hdf,}
                                 \DataTypeTok{prop_id =} \StringTok{'pinx'}\NormalTok{,}
                                 \DataTypeTok{trans_id =} \StringTok{'sale_id'}\NormalTok{,}
                                 \DataTypeTok{price =} \StringTok{'sale_price'}\NormalTok{,}
                                 \DataTypeTok{seq_only =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lrrrrllr@{}}
\toprule
prop\_id & period\_1 & period\_2 & price\_1 & price\_2 & trans\_id1 &
trans\_id2 & pair\_id\tabularnewline
\midrule
\endhead
..0007600057 & 56 & 80 & 520000 & 625000 & 2014..23738 & 2016..28612 &
1\tabularnewline
..0216000010 & 29 & 47 & 1063000 & 1300000 & 2012..12112 & 2013..36837 &
2\tabularnewline
..0342000250 & 40 & 78 & 626800 & 751000 & 2013..11548 & 2016..17781 &
3\tabularnewline
..0342000570 & 15 & 57 & 295000 & 429000 & 2011..4885 & 2014..27574 &
4\tabularnewline
..0342000570 & 57 & 78 & 429000 & 607000 & 2014..27574 & 2016..18557 &
5\tabularnewline
..0345000485 & 8 & 31 & 622000 & 517000 & 2010..15338 & 2012..17939 &
6\tabularnewline
\bottomrule
\end{longtable}

\paragraph{Modeling}\label{modeling}

Next, we use the \texttt{rtdata} object to estimate a repeat
transactions model. In this simple example we will use the
\emph{``base''} estimator (a simple OLS) with a logged dependent
variable (\texttt{log\_dep\ =\ TRUE}). Models may also be estimated via
a robust regression model (\texttt{estimator\ =\ "robust"}) or a
weighted OLS model (\texttt{estimator\ =\ "weighted"}) as originally
suggested by Case and Shiller (1987).

The \texttt{hpiModel()} function is an S3 method that will dispatch on
the class of the object that is passed to its \texttt{hpi\_df} argumet.
In this case that class is \texttt{rtdata} signifying that the data is
in repeat-transaction format. Again, we'll use a base estimator here
with a logged dependent variable. The \texttt{hpiModel()} function
returns an object of class \texttt{hpimodel} that includes the full
regression model results, extracted and cleaned coefficients as well as
additional information on the approach.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_model <-}\StringTok{ }\KeywordTok{hpiModel}\NormalTok{(}\DataTypeTok{model_type =} \StringTok{'rt'}\NormalTok{,}
                       \DataTypeTok{hpi_df =}\NormalTok{ sales_rtdf,}
                       \DataTypeTok{estimator =} \StringTok{'base'}\NormalTok{,}
                       \DataTypeTok{log_dep =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The objects created by regression models can be rather large, so by
default the \texttt{hpiModel()} function trims some of the unnecessary
results from the model estimation function(s). If you want full results
you can set \texttt{trim\_model\ =\ FALSE}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_full <-}\StringTok{ }\KeywordTok{hpiModel}\NormalTok{(}\DataTypeTok{model_type =} \StringTok{'rt'}\NormalTok{,}
                      \DataTypeTok{hpi_df =}\NormalTok{ sales_rtdf,}
                      \DataTypeTok{estimator =} \StringTok{'base'}\NormalTok{,}
                      \DataTypeTok{log_dep =} \OtherTok{TRUE}\NormalTok{,}
                      \DataTypeTok{trim_model =} \OtherTok{FALSE}\NormalTok{)}

  \KeywordTok{object.size}\NormalTok{(rt_model)}
\NormalTok{## 591816 bytes}
  \KeywordTok{object.size}\NormalTok{(rt_full)}
\NormalTok{## 1079744 bytes}
\end{Highlighting}
\end{Shaded}

\paragraph{Index Creation}\label{index-creation}

We can then convert model results into an index with the
\texttt{modelToIndex()} function. The output of this function is an
objet of class \texttt{hpiindex}, which has a time-series object
(\$value slot, class \texttt{ts}) with an index value (base = 100) for
each of the time periods estimated. Note that no smoothing is done at
this time.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_index <-}\StringTok{ }\KeywordTok{modelToIndex}\NormalTok{(}\DataTypeTok{model_obj =}\NormalTok{ rt_model)}
\end{Highlighting}
\end{Shaded}

If you want to limit the extent of the index (clip periods from the end
of it) you can set the \texttt{max\_period} argument within the
\texttt{modelToIndex()} function to the last period you wish to have in
the index.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_short <-}\StringTok{ }\KeywordTok{modelToIndex}\NormalTok{(}\DataTypeTok{model_obj =}\NormalTok{ rt_model,}
                           \DataTypeTok{max_period =} \DecValTok{50}\NormalTok{)}
  \KeywordTok{length}\NormalTok{(rt_short}\OperatorTok{$}\NormalTok{value)}
\NormalTok{## [1] 50}
\end{Highlighting}
\end{Shaded}

A simple plot (with the \texttt{plot.hpiindex()} method) shows the
results of this estimation.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{plot}\NormalTok{(rt_index)}
\end{Highlighting}
\end{Shaded}

\includegraphics{hpir_ares2019_files/figure-latex/index_plot-1.pdf}

In situations where there are empty periods in the modeling results
(there was no or not enough data to estimate a value for a particular
period), the \texttt{modelToIndex()} will impute (using the
\texttt{imputeTS} package) the missing periods. For missing periods at
the start of the index or before the first non-100 period, all periods
are given a value of 100. For missing internal periods (those with
estimated periods both before and after) a `stine' interpolation is used
and for those missing at the end a `last observation carried forward'
(LOCF) approach is used. The \texttt{\textbackslash{}\$imputed} slot in
the \texttt{hpiindex} object will indicate which periods have been
imputed.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_model_imp <-}\StringTok{ }\NormalTok{rt_full}
\NormalTok{  rt_model_imp}\OperatorTok{$}\NormalTok{coefficients}\OperatorTok{$}\NormalTok{coefficient[}\DecValTok{3}\OperatorTok{:}\DecValTok{5}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{  rt_index_imp <-}\StringTok{ }\KeywordTok{modelToIndex}\NormalTok{(}\DataTypeTok{model_obj =}\NormalTok{ rt_model_imp)}
\NormalTok{## Total of 3 period(s) imputed}

\NormalTok{  rt_index_imp}\OperatorTok{$}\NormalTok{value[}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{]}
\NormalTok{## [1] 100.00000  94.32403  93.77995  93.50346  93.37582  93.33960}
  
\NormalTok{  rt_index_imp}\OperatorTok{$}\NormalTok{imputed[}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{]}
\NormalTok{## [1] 0 0 1 1 1 0}
\end{Highlighting}
\end{Shaded}

The plot function can show the imputed periods as well with
\texttt{show\_imputed=TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_model_imp <-}\StringTok{ }\NormalTok{rt_full}
\NormalTok{  rt_model_imp}\OperatorTok{$}\NormalTok{coefficients}\OperatorTok{$}\NormalTok{coefficient[}\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{55}\NormalTok{, }\DecValTok{78}\NormalTok{, }\DecValTok{83}\NormalTok{)] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{  rt_index_imp <-}\StringTok{ }\KeywordTok{modelToIndex}\NormalTok{(}\DataTypeTok{model_obj =}\NormalTok{ rt_model_imp)}
\NormalTok{## Total of 6 period(s) imputed}

  \KeywordTok{plot}\NormalTok{(rt_index_imp, }\DataTypeTok{show_imputed=}\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{hpir_ares2019_files/figure-latex/imp_plot-1.pdf}

\paragraph{Smoothing}\label{smoothing}

As we see from the plots of the indexes above, considerable volatility
from one period to the next is common. Smoothing of indexes may be
warranted as indexes resulting from raw model results often exhibit
greater volatility than is actually occuring in the market. The
\texttt{smoothIndex()} function will smooth via a moving average
function, with small corrections to keep index length after smoothing.
The amount of smoothing is controlled by the \texttt{order} argument --
the number of periods over which to smooth. Note that the \texttt{order}
is saved in the attributes of the \texttt{indexsmooth} object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_smooth <-}\StringTok{ }\KeywordTok{smoothIndex}\NormalTok{(}\DataTypeTok{index_obj =}\NormalTok{ rt_index,}
                           \DataTypeTok{order =} \DecValTok{5}\NormalTok{)}
  \KeywordTok{attr}\NormalTok{(rt_smooth, }\StringTok{'order'}\NormalTok{)}
\NormalTok{## [1] 5}
\end{Highlighting}
\end{Shaded}

The \texttt{smoothIndex()} function can be done \textbf{`in\_place'}
such that the smoothed indexes are added to the larger \texttt{hpiindex}
object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{   rt_index <-}\StringTok{ }\KeywordTok{smoothIndex}\NormalTok{(}\DataTypeTok{index_obj =}\NormalTok{ rt_index,}
                           \DataTypeTok{order =} \DecValTok{7}\NormalTok{,}
                           \DataTypeTok{in_place =} \OtherTok{TRUE}\NormalTok{)}
   \KeywordTok{names}\NormalTok{(rt_index)}
\NormalTok{## [1] "name"    "numeric" "period"  "value"   "imputed" "smooth"}
\end{Highlighting}
\end{Shaded}

The \textbf{in\_place} smoothing can be plotted by adding
\texttt{smooth=TRUE} to the plot call.

\begin{Shaded}
\begin{Highlighting}[]
   \KeywordTok{plot}\NormalTok{(rt_index, }\DataTypeTok{smooth=}\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{hpir_ares2019_files/figure-latex/plot_smooth-1.pdf}

\paragraph{Data to Index Wrapper}\label{data-to-index-wrapper}

A wrapper function, \texttt{rtIndex()}, will do all of the above taking
it from a raw \texttt{data.frame} of transaction data through to the
repeat transaction index creation and storing all results in a unified
object of class \texttt{hpi}.

There are three `levels of entry' with the wrapper function.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  You can give it a raw \texttt{data.frame} with your transactions and
  it will A) Add the periods; B) Calculate the repeat transactions; and
  C) Model the data and create the index. Under this approach
  \texttt{trans\_df} is passed a raw \texttt{data.frame} along with the
  following arguments, some of which are optional (will revert to
  default if not given) and some of which are required (mostly field
  names):
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{periodicity} (optional: default = `annual')
\item
  \texttt{min\_date} (optional: default = minimum of data)
\item
  \texttt{max\_date} (optional: default = maximum of data)
\item
  \texttt{adj\_type} (opt: default = `move')
\item
  \texttt{date} (required)
\item
  \texttt{price} (required)
\item
  \texttt{trans\_id} (required)
\item
  \texttt{prop\_id} (required)
\item
  \texttt{seq\_only} (optional: default = FALSE)
\item
  \texttt{estimator} (optional: default = `base')
\item
  \texttt{log\_dep} (optional: default = TRUE)
\item
  \texttt{trim\_model} (optional: default = FALSE)
\item
  \texttt{max\_period} (optional: default = maximum of index length)
\item
  \texttt{smooth} (optional: default = FALSE)
\item
  \texttt{smooth\_order} (optional, default = 3)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_}\DecValTok{1}\NormalTok{ <-}\StringTok{ }\KeywordTok{rtIndex}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ ex_sales,}
                  \DataTypeTok{periodicity =} \StringTok{'monthly'}\NormalTok{,}
                  \DataTypeTok{min_date =} \StringTok{'2010-06-01'}\NormalTok{,}
                  \DataTypeTok{max_date =} \StringTok{'2015-11-30'}\NormalTok{,}
                  \DataTypeTok{adj_type =} \StringTok{'clip'}\NormalTok{,}
                  \DataTypeTok{date =} \StringTok{'sale_date'}\NormalTok{,}
                  \DataTypeTok{price =} \StringTok{'sale_price'}\NormalTok{,}
                  \DataTypeTok{trans_id =} \StringTok{'sale_id'}\NormalTok{,}
                  \DataTypeTok{prop_id =} \StringTok{'pinx'}\NormalTok{,}
                  \DataTypeTok{seq_only =} \OtherTok{TRUE}\NormalTok{,}
                  \DataTypeTok{estimator =} \StringTok{'robust'}\NormalTok{,}
                  \DataTypeTok{log_dep =} \OtherTok{TRUE}\NormalTok{,}
                  \DataTypeTok{trim_model =} \OtherTok{TRUE}\NormalTok{,}
                  \DataTypeTok{max_period =} \DecValTok{48}\NormalTok{,}
                  \DataTypeTok{smooth =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{## Supplied "min_date" date is greater than minimum of transactions. Clipping transactions.}
\NormalTok{## Supplied "max_date" is less than maximum of transactions. Clipping transactions.}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  You can provide a \texttt{hpidata} object (one that has been through
  the \texttt{dateToPeriod()} function). In this case, the following
  arguments are valid:
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{date} (required)
\item
  \texttt{price} (required)
\item
  \texttt{trans\_id} (required)
\item
  \texttt{prop\_id} (required)
\item
  \texttt{seq\_only} (optional: default = FALSE)
\item
  \texttt{estimator} (optional: default = `base')
\item
  \texttt{log\_dep} (optional: default = TRUE)
\item
  \texttt{trim\_model} (optional: default = FALSE)
\item
  \texttt{max\_period} (optional: default = maximum of index length)
\item
  \texttt{smooth} (optional: default = FALSE)
\item
  \texttt{smooth\_order} (optional, default = 3)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]

\NormalTok{  sales_hdf <-}\StringTok{ }\KeywordTok{dateToPeriod}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ ex_sales,}
                            \DataTypeTok{date =} \StringTok{'sale_date'}\NormalTok{,}
                            \DataTypeTok{periodicity =} \StringTok{'monthly'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_}\DecValTok{2}\NormalTok{ <-}\StringTok{ }\KeywordTok{rtIndex}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ sales_hdf,}
                  \DataTypeTok{date =} \StringTok{'sale_date'}\NormalTok{,}
                  \DataTypeTok{price =} \StringTok{'sale_price'}\NormalTok{,}
                  \DataTypeTok{trans_id =} \StringTok{'sale_id'}\NormalTok{,}
                  \DataTypeTok{prop_id =} \StringTok{'pinx'}\NormalTok{,}
                  \DataTypeTok{seq_only =} \OtherTok{FALSE}\NormalTok{,}
                  \DataTypeTok{estimator =} \StringTok{'weighted'}\NormalTok{,}
                  \DataTypeTok{log_dep =} \OtherTok{FALSE}\NormalTok{,}
                  \DataTypeTok{trim_model =} \OtherTok{FALSE}\NormalTok{,}
                  \DataTypeTok{max_period =} \DecValTok{56}\NormalTok{,}
                  \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Finally, you can provide it an \texttt{rtdata} object (one that has
  been through the \texttt{rtCreateTrans()} function). Only the
  following arguments are meaningful in this case.
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{estimator} (optional: default = `base')
\item
  \texttt{log\_dep} (optional: default = TRUE)
\item
  \texttt{trim\_model} (optional: default = FALSE)
\item
  \texttt{max\_period} (optional: default = maximum of index length)
\item
  \texttt{smooth} (optional: default = FALSE)
\item
  \texttt{smooth\_order} (optional, default = 3)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  sales_rtdf <-}\StringTok{ }\KeywordTok{rtCreateTrans}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ sales_hdf,}
                            \DataTypeTok{prop_id =} \StringTok{'pinx'}\NormalTok{,}
                            \DataTypeTok{trans_id =} \StringTok{'sale_id'}\NormalTok{,}
                            \DataTypeTok{price =} \StringTok{'sale_price'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_}\DecValTok{3}\NormalTok{ <-}\StringTok{ }\KeywordTok{rtIndex}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ sales_rtdf,}
                  \DataTypeTok{estimator =} \StringTok{'robust'}\NormalTok{,}
                  \DataTypeTok{log_dep =} \OtherTok{TRUE}\NormalTok{,}
                  \DataTypeTok{trim_model =} \OtherTok{FALSE}\NormalTok{,}
                  \DataTypeTok{max_period =} \DecValTok{80}\NormalTok{,}
                  \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{,}
                  \DataTypeTok{smooth_order =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A plot method exists to cleanly plot \texttt{hpi} objects.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{plot}\NormalTok{(rt_}\DecValTok{3}\NormalTok{, }\DataTypeTok{smooth=}\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{hpir_ares2019_files/figure-latex/plot_rt3`-1.pdf}

\subsubsection{Hedonic Price Model}\label{hedonic-price-model}

Another option for developing a house price index is to use a hedonic
price model. Similar to the repeat transaction model presented above,
this process can be done stepwise or through a single wrapper function
(\texttt{hedIndex()}). We'll start with individual steps.

First, we create a set of hedonic model ready data with the
\texttt{hedCreateTrans()} function. Here we provide the raw
transactions, along with field names for the property id, the
transaction ids, the price and date. A periodicity (\emph{``yearly''},
\emph{``quarterly''}, \emph{``monthly''} or \emph{``weekly''}) is also
required. Note that this function uses the \texttt{dateToPeriod()}
discussed above and creates an object of class \texttt{heddata}
inheriting from \texttt{hpidata} and \texttt{data.frame}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  sales_hhdf <-}\StringTok{ }\KeywordTok{hedCreateTrans}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ ex_sales,}
                               \DataTypeTok{prop_id =} \StringTok{'pinx'}\NormalTok{,}
                               \DataTypeTok{trans_id =} \StringTok{'sale_id'}\NormalTok{,}
                               \DataTypeTok{price =} \StringTok{'sale_price'}\NormalTok{,}
                               \DataTypeTok{date=} \StringTok{'sale_date'}\NormalTok{,}
                               \DataTypeTok{periodicity =} \StringTok{'monthly'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Next, we estimate the hedonic model. There are two ways to specify the
model. First, you can provide the dependent variable and independent
variable(s) directly, as in the example below. These will simply be
combined as a basic linear formula. The \texttt{log\_dep} argument will
control whether or not the dependent variable (\texttt{dep\_var}) is
converted into log format (as is common in hedonic price studies).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  hed_model <-}\StringTok{ }\KeywordTok{hpiModel}\NormalTok{(}\DataTypeTok{model_type =} \StringTok{'hed'}\NormalTok{,}
                        \DataTypeTok{hpi_df =}\NormalTok{ sales_hhdf,}
                        \DataTypeTok{estimator =} \StringTok{'base'}\NormalTok{,}
                        \DataTypeTok{dep_var =} \StringTok{'price'}\NormalTok{,}
                        \DataTypeTok{ind_var =} \KeywordTok{c}\NormalTok{(}\StringTok{'tot_sf'}\NormalTok{, }\StringTok{'beds'}\NormalTok{, }\StringTok{'baths'}\NormalTok{),}
                        \DataTypeTok{log_dep =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If you'd like more control over the model specification -- such as using
interactions or categorical variables -- you can, instead, provide a
fully formed model specification in the \texttt{hed\_spec} argument.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  model_spec <-}\StringTok{ }\KeywordTok{as.formula}\NormalTok{(}\StringTok{'log(price) ~ as.factor(baths) + tot_sf'}\NormalTok{)}
  
\NormalTok{  hed_model <-}\StringTok{ }\KeywordTok{hpiModel}\NormalTok{(}\DataTypeTok{model_type =} \StringTok{'hed'}\NormalTok{,}
                        \DataTypeTok{hpi_df =}\NormalTok{ sales_hhdf,}
                        \DataTypeTok{estimator =} \StringTok{'base'}\NormalTok{,}
                        \DataTypeTok{mod_spec =}\NormalTok{ model_spec,}
                        \DataTypeTok{log_dep =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In addition to the base estimator (OLS) there are robust regression
(\texttt{estimator\ =\ "robust"}) and weighted least squares
(\texttt{estimator\ =\ "weighted"}) options.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  hed_model_rob <-}\StringTok{ }\KeywordTok{hpiModel}\NormalTok{(}\DataTypeTok{model_type =} \StringTok{'hed'}\NormalTok{,}
                            \DataTypeTok{hpi_df =}\NormalTok{ sales_hhdf,}
                            \DataTypeTok{estimator =} \StringTok{'robust'}\NormalTok{,}
                            \DataTypeTok{dep_var =} \StringTok{'price'}\NormalTok{,}
                            \DataTypeTok{ind_var =} \KeywordTok{c}\NormalTok{(}\StringTok{'tot_sf'}\NormalTok{, }\StringTok{'beds'}\NormalTok{, }\StringTok{'baths'}\NormalTok{),}
                            \DataTypeTok{log_dep =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Do note that the weighted option requires a vectors of weights.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  hed_model_wgt <-}\StringTok{ }\KeywordTok{hpiModel}\NormalTok{(}\DataTypeTok{model_type =} \StringTok{'hed'}\NormalTok{,}
                            \DataTypeTok{hpi_df =}\NormalTok{ sales_hhdf,}
                            \DataTypeTok{estimator =} \StringTok{'weighted'}\NormalTok{,}
                            \DataTypeTok{dep_var =} \StringTok{'price'}\NormalTok{,}
                            \DataTypeTok{ind_var =} \KeywordTok{c}\NormalTok{(}\StringTok{'tot_sf'}\NormalTok{, }\StringTok{'beds'}\NormalTok{, }\StringTok{'baths'}\NormalTok{),}
                            \DataTypeTok{log_dep =} \OtherTok{FALSE}\NormalTok{,}
                            \DataTypeTok{weights =} \KeywordTok{runif}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(sales_hhdf), }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

The output from \texttt{hpiModel()} can be converted to an index with
the \texttt{modelToIndex()} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  hed_index <-}\StringTok{ }\KeywordTok{modelToIndex}\NormalTok{(}\DataTypeTok{model_obj =}\NormalTok{ hed_model)}
\end{Highlighting}
\end{Shaded}

And, again, this can be plotted to shown the index.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{plot}\NormalTok{(hed_index)}
\end{Highlighting}
\end{Shaded}

\includegraphics{hpir_ares2019_files/figure-latex/plot_hedindex-1.pdf}

The \texttt{hedIndex()} wrapper function will perform all of the above
hedonic modeling tasks, and then condense the results into an unified
object of class \texttt{hpi}.

There are three `levels of entry' with the wrapper function.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  You can give it a raw \texttt{data.frame} with your transactions and
  it will A) Add the periods; B) Create a hedonic sales object; and 3)
  Model the data and create the index. Under this approach
  \texttt{trans\_df} is passed a raw \texttt{data.frame} along with the
  following arguments, some of which are optional (will revert to
  default if not given) and some of which are required (mostly field
  names and the model specification):
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{periodicity} (optional: default = `annual')
\item
  \texttt{min\_date} (optional: default = minimum of data)
\item
  \texttt{max\_date} (optional: default = maximum of data)
\item
  \texttt{adj\_type} (opt: default = `move')
\item
  \texttt{date} (required)
\item
  \texttt{price} (required)
\item
  \texttt{trans\_id} (required)
\item
  \texttt{prop\_id} (required)
\item
  \texttt{dep\_var} (required, unless \texttt{hed\_spec} supplied)
\item
  \texttt{ind\_var} (required, unless \texttt{hed\_spec} supplied)
\item
  \texttt{hed\_spec} (required, unless \texttt{dep\_var} and
  \texttt{ind\_var} supplied)
\item
  \texttt{estimator} (optional: default = `base')
\item
  \texttt{log\_dep} (optional: default = TRUE)
\item
  \texttt{trim\_model} (optional: default = FALSE)
\item
  \texttt{max\_period} (optional: default = maximum of data)
\item
  \texttt{smooth} (optional: default = FALSE)
\item
  \texttt{smooth\_order} (optional, default = 3)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  hed_}\DecValTok{1}\NormalTok{ <-}\StringTok{ }\KeywordTok{hedIndex}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ ex_sales,}
                    \DataTypeTok{periodicity =} \StringTok{'monthly'}\NormalTok{,}
                    \DataTypeTok{min_date =} \StringTok{'2010-06-01'}\NormalTok{,}
                    \DataTypeTok{max_date =} \StringTok{'2015-11-30'}\NormalTok{,}
                    \DataTypeTok{adj_type =} \StringTok{'clip'}\NormalTok{,}
                    \DataTypeTok{date =} \StringTok{'sale_date'}\NormalTok{,}
                    \DataTypeTok{price =} \StringTok{'sale_price'}\NormalTok{,}
                    \DataTypeTok{trans_id =} \StringTok{'sale_id'}\NormalTok{,}
                    \DataTypeTok{prop_id =} \StringTok{'pinx'}\NormalTok{,}
                    \DataTypeTok{estimator =} \StringTok{'robust'}\NormalTok{,}
                    \DataTypeTok{log_dep =} \OtherTok{TRUE}\NormalTok{,}
                    \DataTypeTok{trim_model =} \OtherTok{TRUE}\NormalTok{,}
                    \DataTypeTok{max_period =} \DecValTok{48}\NormalTok{,}
                    \DataTypeTok{dep_var =} \StringTok{'price'}\NormalTok{,}
                    \DataTypeTok{ind_var =} \KeywordTok{c}\NormalTok{(}\StringTok{'tot_sf'}\NormalTok{, }\StringTok{'beds'}\NormalTok{, }\StringTok{'baths'}\NormalTok{),}
                    \DataTypeTok{smooth =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{## Supplied "min_date" date is greater than minimum of transactions. Clipping transactions.}
\NormalTok{## Supplied "max_date" is less than maximum of transactions. Clipping transactions.}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  You can provide an \texttt{hpidata} object (one that has been through
  the \texttt{dateToPeriod()} function). In this case, the following
  arguments are valid:
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{date} (required)
\item
  \texttt{price} (required)
\item
  \texttt{trans\_id} (required)
\item
  \texttt{prop\_id} (required)
\item
  \texttt{dep\_var} (required, unless \texttt{hed\_spec} supplied)
\item
  \texttt{ind\_var} (required, unless \texttt{hed\_spec} supplied)
\item
  \texttt{hed\_spec} (required, unless \texttt{dep\_var} and
  \texttt{ind\_var} supplied)
\item
  \texttt{estimator} (optional: default = `base')
\item
  \texttt{log\_dep} (optional: default = TRUE)
\item
  \texttt{trim\_model} (optional: default = FALSE)
\item
  \texttt{max\_period} (optional: default = maximum of data)
\item
  \texttt{smooth} (optional: default = FALSE)
\item
  \texttt{smooth\_order} (optional, default = 3)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  sales_hdf <-}\StringTok{ }\KeywordTok{dateToPeriod}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ ex_sales,}
                           \DataTypeTok{date =} \StringTok{'sale_date'}\NormalTok{,}
                           \DataTypeTok{periodicity =} \StringTok{'monthly'}\NormalTok{,}
                           \DataTypeTok{min_date =} \StringTok{'2010-02-01'}\NormalTok{,}
                           \DataTypeTok{max_date =} \StringTok{'2015-11-30'}\NormalTok{,}
                           \DataTypeTok{adj_type =} \StringTok{'move'}\NormalTok{)}
\NormalTok{## Supplied "min_date" is greater than minimum of transactions. Adjusting.}
\NormalTok{## Supplied "max_date" is less than maximum of transactions. Adjusting.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  hed_}\DecValTok{2}\NormalTok{ <-}\StringTok{ }\KeywordTok{hedIndex}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ sales_hdf,}
                    \DataTypeTok{date =} \StringTok{'sale_date'}\NormalTok{,}
                    \DataTypeTok{price =} \StringTok{'sale_price'}\NormalTok{,}
                    \DataTypeTok{trans_id =} \StringTok{'sale_id'}\NormalTok{,}
                    \DataTypeTok{prop_id =} \StringTok{'pinx'}\NormalTok{,}
                    \DataTypeTok{estimator =} \StringTok{'base'}\NormalTok{,}
                    \DataTypeTok{log_dep =} \OtherTok{FALSE}\NormalTok{,}
                    \DataTypeTok{trim_model =} \OtherTok{FALSE}\NormalTok{,}
                    \DataTypeTok{max_period =} \DecValTok{56}\NormalTok{,}
                    \DataTypeTok{dep_var =} \StringTok{'price'}\NormalTok{,}
                    \DataTypeTok{ind_var =} \KeywordTok{c}\NormalTok{(}\StringTok{'tot_sf'}\NormalTok{, }\StringTok{'beds'}\NormalTok{, }\StringTok{'baths'}\NormalTok{),}
                    \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Finally, you can provide it an \texttt{heddata} object (one that has
  been through the \texttt{hedCreateTrans()} function). Only the
  following arguments can be given in this case.
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{dep\_var} (required, unless \texttt{hed\_spec} supplied)
\item
  \texttt{ind\_var} (required, unless \texttt{hed\_spec} supplied)
\item
  \texttt{hed\_spec} (required, unless \texttt{dep\_var} and
  \texttt{ind\_var} supplied)
\item
  \texttt{estimator} (optional: default = `base')
\item
  \texttt{log\_dep} (optional: default = TRUE)
\item
  \texttt{trim\_model} (optional: default = FALSE)
\item
  \texttt{max\_period} (optional: default = maximum of data)
\item
  \texttt{smooth} (optional: default = FALSE)
\item
  \texttt{smooth\_order} (optional, default = 3)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  sales_hhdf <-}\StringTok{ }\KeywordTok{hedCreateTrans}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ sales_hdf,}
                               \DataTypeTok{prop_id =} \StringTok{'pinx'}\NormalTok{,}
                               \DataTypeTok{trans_id =} \StringTok{'sale_id'}\NormalTok{,}
                               \DataTypeTok{price =} \StringTok{'sale_price'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  hed_}\DecValTok{3}\NormalTok{ <-}\StringTok{ }\KeywordTok{hedIndex}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ sales_hhdf,}
                    \DataTypeTok{estimator =} \StringTok{'weighted'}\NormalTok{,}
                    \DataTypeTok{log_dep =} \OtherTok{TRUE}\NormalTok{,}
                    \DataTypeTok{trim_model =} \OtherTok{FALSE}\NormalTok{,}
                    \DataTypeTok{max_period =} \DecValTok{80}\NormalTok{,}
                    \DataTypeTok{dep_var =} \StringTok{'price'}\NormalTok{,}
                    \DataTypeTok{ind_var =} \KeywordTok{c}\NormalTok{(}\StringTok{'tot_sf'}\NormalTok{, }\StringTok{'beds'}\NormalTok{, }\StringTok{'baths'}\NormalTok{),}
                    \DataTypeTok{weights =} \KeywordTok{runif}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(sales_hhdf), }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{),}
                    \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{,}
                    \DataTypeTok{smooth_order =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Again, we can plot with a simple \texttt{plot()} call.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{plot}\NormalTok{(hed_}\DecValTok{3}\NormalTok{, }\DataTypeTok{smooth=}\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{hpir_ares2019_files/figure-latex/plot_hed3-1.pdf}

\subsubsection{Analyzing an index}\label{analyzing-an-index}

Before we start analyzing our indexes, we'll create two example
\texttt{hpi} objects, one using a repeat sales model and one with a
hedonic price model.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_hpi <-}\StringTok{ }\KeywordTok{rtIndex}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ sales_rtdf,}
                    \DataTypeTok{estimator =} \StringTok{'robust'}\NormalTok{,}
                    \DataTypeTok{log_dep =} \OtherTok{TRUE}\NormalTok{,}
                    \DataTypeTok{trim_model =} \OtherTok{FALSE}\NormalTok{,}
                    \DataTypeTok{max_period =} \DecValTok{84}\NormalTok{,}
                    \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{)}

\NormalTok{  hed_hpi <-}\StringTok{ }\KeywordTok{hedIndex}\NormalTok{(}\DataTypeTok{trans_df =}\NormalTok{ sales_hhdf,}
                      \DataTypeTok{estimator =} \StringTok{'weighted'}\NormalTok{,}
                      \DataTypeTok{log_dep =} \OtherTok{TRUE}\NormalTok{,}
                      \DataTypeTok{trim_model =} \OtherTok{FALSE}\NormalTok{,}
                      \DataTypeTok{max_period =} \DecValTok{84}\NormalTok{,}
                      \DataTypeTok{dep_var =} \StringTok{'price'}\NormalTok{,}
                      \DataTypeTok{ind_var =} \KeywordTok{c}\NormalTok{(}\StringTok{'tot_sf'}\NormalTok{, }\StringTok{'beds'}\NormalTok{, }\StringTok{'baths'}\NormalTok{),}
                      \DataTypeTok{weights =} \KeywordTok{runif}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(sales_hhdf), }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{),}
                      \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\paragraph{Volatility}\label{volatility}

One thing we can check for an index is its volatility. We can get the a
rolling window volatility (standard deviation) of the index with the
\texttt{calcIndexVolatility()} function. The \texttt{window} over which
to calculate the volatility can be specified. Both volatility metrics at
each window calculation (\texttt{\textbackslash{}\$roll}) as well as the
summarized average volality(\texttt{\textbackslash{}\$mean}) and median
(\texttt{\textbackslash{}\$median}) are returned by the function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  index_vol <-}\StringTok{ }\KeywordTok{calcVolatility}\NormalTok{(}\DataTypeTok{index =}\NormalTok{ hed_hpi}\OperatorTok{$}\NormalTok{index}\OperatorTok{$}\NormalTok{value,}
                              \DataTypeTok{window =} \DecValTok{3}\NormalTok{)}
  \KeywordTok{names}\NormalTok{(index_vol)}
\NormalTok{## [1] "roll"   "mean"   "median"}
\end{Highlighting}
\end{Shaded}

Plotting an \texttt{indexvolatility} object shows the rolling
volatility, the mean (dashed line) and the median (dotted) volatility on
the top panel.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{plot}\NormalTok{(index_vol)}
\NormalTok{## Warning: Removed 3 rows containing missing values (geom_path).}
\end{Highlighting}
\end{Shaded}

\includegraphics{hpir_ares2019_files/figure-latex/plot_vol-1.pdf}

A number of differently classed objects can be passed to the
\texttt{index} argument in the \texttt{calcVolatility()} function. These
include the extracted \texttt{ts} object from an \texttt{hpiindex}
object (as done above), the raw \texttt{hpiindex} object itself (from
\texttt{modelToIndex()}), or an \texttt{hpi} object from one of the
wrappers (\texttt{rtIndex()} or \texttt{hedIndex()})

\begin{Shaded}
\begin{Highlighting}[]
 \CommentTok{# hpinindex object}
\NormalTok{ index_vol <-}\StringTok{ }\KeywordTok{calcVolatility}\NormalTok{(}\DataTypeTok{index =}\NormalTok{ hed_hpi}\OperatorTok{$}\NormalTok{index,}
                             \DataTypeTok{window =} \DecValTok{3}\NormalTok{)}

 \CommentTok{# hpi object}
\NormalTok{ index_vol <-}\StringTok{ }\KeywordTok{calcVolatility}\NormalTok{(}\DataTypeTok{index =}\NormalTok{ hed_hpi,}
                             \DataTypeTok{window =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If you want to calculate the volatility of the smoothed index, you need
to pass the smoothed index directly or change the \texttt{smooth}
argument to TRUE (default is false) when passing an \texttt{hpiindex} or
\texttt{hpi} object to \texttt{calcVolatility()}. Note, you must make
sure that a `smoothed' index exists in the \texttt{hpi} or
\texttt{hpindex} object first.

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{# Direct passing}
\NormalTok{  sindex_vol <-}\StringTok{ }\KeywordTok{calcVolatility}\NormalTok{(}\DataTypeTok{index =}\NormalTok{ hed_hpi}\OperatorTok{$}\NormalTok{index}\OperatorTok{$}\NormalTok{smooth,}
                               \DataTypeTok{window =} \DecValTok{3}\NormalTok{)}

  \CommentTok{# While passing 'hpi' or 'hpiindex'}
\NormalTok{  sindex_vol <-}\StringTok{ }\KeywordTok{calcVolatility}\NormalTok{(}\DataTypeTok{index =}\NormalTok{ hed_hpi}\OperatorTok{$}\NormalTok{index,}
                               \DataTypeTok{window =} \DecValTok{3}\NormalTok{,}
                               \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{calcVolatility()} function can also place the volatility
metrics directly into the \texttt{hpiindex} object by setting
\texttt{in\_place\ =\ TRUE}. If passed an \texttt{hpiindex} object, the
results will be stored in the \texttt{hpiindex} object which is
returned. If passed an \texttt{hpi} object, the results will be stored
in the \texttt{hpiindex} object within the \texttt{hpi} object which is
returned.

\begin{Shaded}
\begin{Highlighting}[]
   \CommentTok{# Add it to the 'hpiindex' object}
\NormalTok{   hed_hpi}\OperatorTok{$}\NormalTok{index <-}\StringTok{ }\KeywordTok{calcVolatility}\NormalTok{(}\DataTypeTok{index =}\NormalTok{ hed_hpi}\OperatorTok{$}\NormalTok{index,}
                                   \DataTypeTok{window =} \DecValTok{3}\NormalTok{,}
                                   \DataTypeTok{in_place =} \OtherTok{TRUE}\NormalTok{)}

   \CommentTok{# Add it to the full 'hpi' object (to the hpiindex object)}
\NormalTok{   hed_hpi <-}\StringTok{ }\KeywordTok{calcVolatility}\NormalTok{(}\DataTypeTok{index =}\NormalTok{ hed_hpi,}
                             \DataTypeTok{window =} \DecValTok{3}\NormalTok{,}
                             \DataTypeTok{in_place =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A volatility analysis of a smoothed index will place it under the
\textbf{\$volatility\_smooth} name.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{   hed_hpi <-}\StringTok{ }\KeywordTok{calcVolatility}\NormalTok{(}\DataTypeTok{index =}\NormalTok{ hed_hpi,}
                             \DataTypeTok{window =} \DecValTok{3}\NormalTok{,}
                             \DataTypeTok{in_place =} \OtherTok{TRUE}\NormalTok{,}
                             \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{)}
   \KeywordTok{names}\NormalTok{(hed_hpi}\OperatorTok{$}\NormalTok{index)}
\NormalTok{## [1] "name"              "numeric"           "period"           }
\NormalTok{## [4] "value"             "imputed"           "smooth"           }
\NormalTok{## [7] "volatility"        "volatility_smooth"}
\end{Highlighting}
\end{Shaded}

If you want to add it to the \texttt{hpiindex} object under a different
name -- say if you are comparing volatilities of different windows --
you can use the \texttt{in\_place\_name} argument to give it a different
name than the defaults (`volatility' and `volatility\_smoothed')

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{   hed_index <-}\StringTok{ }\KeywordTok{calcVolatility}\NormalTok{(}\DataTypeTok{index =}\NormalTok{ hed_hpi}\OperatorTok{$}\NormalTok{index,}
                               \DataTypeTok{window =} \DecValTok{3}\NormalTok{,}
                               \DataTypeTok{in_place =} \OtherTok{TRUE}\NormalTok{,}
                               \DataTypeTok{in_place_name =} \StringTok{'vol_3'}\NormalTok{)}
   \KeywordTok{names}\NormalTok{(hed_index)}
\NormalTok{## [1] "name"              "numeric"           "period"           }
\NormalTok{## [4] "value"             "imputed"           "smooth"           }
\NormalTok{## [7] "volatility"        "volatility_smooth" "vol_3"}
\end{Highlighting}
\end{Shaded}

A note on renaming and in place addition. All of the analytical objects
that are added -- volatility and other below -- can be renamed to allow
for multiple analyses with different parameters. Smoothed indexes,
however, cannot be renamed and must be stored under the name `smooth'
because all of the analytical process depend on identifying this named
slot.

\paragraph{Fitting Accuracy (Index)}\label{fitting-accuracy-index}

Next, we can test the accuracy of an index. In this case, we will define
accuracy as the ability to properly estimate the second transaction
price of a repeat transaction pair (a property that sells
twice).\footnote{Note that a second method using hedonic pricing models
  is being developed.} To start, we'll do this in-sample, ignoring any
issues of overfitting.

The \texttt{calcAccuracy()} function requires a full \texttt{hpi} object
as its main argument. \texttt{test\_type} defines the manner of testing
accuracy; at the moment the only working options is \emph{``rt''} which
uses repeat transactions to judge the accuracy of an index. (Additional
types to come). \texttt{test\_method} sets the manner in which the test
is employed, \emph{``insample''} or \emph{``kfold''}. If the
\texttt{hpi\_obj} does not match the \texttt{test\_type} (in all cases
\emph{``rt''} for now), then you must supply an \texttt{rtdata} object
to in the \texttt{pred\_df} argument.

The \texttt{calcAccuracy()} function returns a \texttt{data.frame}
comparing the actual (repeat) transaction price to the one predicted by
the index. A \texttt{"test\_method"} attribute indicates the type of
accuracy test performed.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{   rt_is_accr <-}\StringTok{ }\KeywordTok{calcAccuracy}\NormalTok{(}\DataTypeTok{hpi_obj =}\NormalTok{ rt_hpi,}
                              \DataTypeTok{test_type =} \StringTok{'rt'}\NormalTok{,}
                              \DataTypeTok{test_method =} \StringTok{'insample'}\NormalTok{)}
   \KeywordTok{attr}\NormalTok{(rt_is_accr, }\StringTok{'test_method'}\NormalTok{)}
\NormalTok{## [1] "insample"}
\end{Highlighting}
\end{Shaded}

The smoothed index (if present) can be analyzed by setting
\texttt{smooth\ =\ TRUE}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    rts_is_accr <-}\StringTok{ }\KeywordTok{calcAccuracy}\NormalTok{(}\DataTypeTok{hpi_obj =}\NormalTok{ rt_hpi,}
                                \DataTypeTok{test_type =} \StringTok{'rt'}\NormalTok{,}
                                \DataTypeTok{test_method =} \StringTok{'insample'}\NormalTok{,}
                                \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

As with the other analytical functions, the results of the accuracy
calculations can be added to the \texttt{hpi\_obj} by returning them in
place (\texttt{in\_place\ ==\ TRUE}). A name (\emph{``default =
`accuracy'\,''}``) may also be given.

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{# Returns an accuracy object in place}
\NormalTok{    hed_hpi <-}\StringTok{ }\KeywordTok{calcAccuracy}\NormalTok{(}\DataTypeTok{hpi_obj =}\NormalTok{ hed_hpi,}
                            \DataTypeTok{test_type =} \StringTok{'rt'}\NormalTok{,}
                            \DataTypeTok{test_method =} \StringTok{'insample'}\NormalTok{,}
                            \DataTypeTok{pred_df =}\NormalTok{ sales_rtdf,}
                            \DataTypeTok{in_place =} \OtherTok{TRUE}\NormalTok{,}
                            \DataTypeTok{in_place_name =} \StringTok{'is_accuracy'}\NormalTok{)}
    \KeywordTok{names}\NormalTok{(hed_hpi)}
\NormalTok{## [1] "data"  "model" "index"}

    \CommentTok{# Returns a smooth accuracy object in place}
\NormalTok{    hed_hpi <-}\StringTok{ }\KeywordTok{calcAccuracy}\NormalTok{(}\DataTypeTok{hpi_obj =}\NormalTok{ hed_hpi,}
                            \DataTypeTok{test_type =} \StringTok{'rt'}\NormalTok{,}
                            \DataTypeTok{test_method =} \StringTok{'insample'}\NormalTok{,}
                            \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{,}
                            \DataTypeTok{pred_df =}\NormalTok{ rt_hpi}\OperatorTok{$}\NormalTok{data,}
                            \DataTypeTok{in_place =} \OtherTok{TRUE}\NormalTok{,}
                            \DataTypeTok{in_place_name =} \StringTok{'smooth_is_accuracy'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To create a better estimate of predictive ability we can employ a
K-fold, out of sample test of accuracy. In a K-fold test, some
percentage of the observations are withheld, the index re-estimated and
then the newly estimated index is judged by its ability to predict the
repeat transaction price in the withheld (out-of) sample.

Two additional arguments are availabile here: 1) \texttt{k} - the number
of folds to make (default = 10); and 2) \texttt{seed} a value to the
control the random sampling (default = 1).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_kf_accr <-}\StringTok{ }\KeywordTok{calcAccuracy}\NormalTok{(}\DataTypeTok{hpi_obj =}\NormalTok{ rt_hpi,}
                             \DataTypeTok{test_type =} \StringTok{'rt'}\NormalTok{,}
                             \DataTypeTok{test_method =} \StringTok{'kfold'}\NormalTok{,}
                             \DataTypeTok{k =} \DecValTok{10}\NormalTok{,}
                             \DataTypeTok{seed =} \DecValTok{123}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can do this with smoothed indexes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_kf_accr_s <-}\StringTok{ }\KeywordTok{calcAccuracy}\NormalTok{(}\DataTypeTok{hpi_obj =}\NormalTok{ rt_hpi,}
                               \DataTypeTok{test_type =} \StringTok{'rt'}\NormalTok{,}
                               \DataTypeTok{test_method =} \StringTok{'kfold'}\NormalTok{,}
                               \DataTypeTok{k =} \DecValTok{10}\NormalTok{,}
                               \DataTypeTok{seed =} \DecValTok{123}\NormalTok{,}
                               \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can also return these in place.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    hed_hpi <-}\StringTok{ }\KeywordTok{calcAccuracy}\NormalTok{(}\DataTypeTok{hpi_obj =}\NormalTok{ hed_hpi,}
                            \DataTypeTok{test_type =} \StringTok{'rt'}\NormalTok{,}
                            \DataTypeTok{test_method =} \StringTok{'kfold'}\NormalTok{,}
                            \DataTypeTok{k =} \DecValTok{10}\NormalTok{,}
                            \DataTypeTok{seed =} \DecValTok{1}\NormalTok{,}
                            \DataTypeTok{pred_df =}\NormalTok{ rt_hpi}\OperatorTok{$}\NormalTok{data,}
                            \DataTypeTok{in_place =} \OtherTok{TRUE}\NormalTok{,}
                            \DataTypeTok{in_place_name =} \StringTok{'kf_accuracy'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A plotting method (\texttt{plot.hpiaccuracy()}) shows a number of
diagnostics about the accuracy analysis. Because the plotting object
here contains multiple plot objects, if you wish to save this plot to a
named object, you need to add \texttt{return\_plot\ =\ TRUE} to the
argument list.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{plot}\NormalTok{(hed_hpi}\OperatorTok{$}\NormalTok{index}\OperatorTok{$}\NormalTok{kf_accuracy)}
\end{Highlighting}
\end{Shaded}

\includegraphics{hpir_ares2019_files/figure-latex/plot_accr-1.pdf}

\subsubsection{Index Series}\label{index-series}

Two other aspects or metrics of house price indexes are revision and
forecast accuracy. Forecast accuracy refers to how well an index
forecast captures future market movements. Revision refers to how much
original index values change over time as new data is accumulated (new
transactions occur). Both concepts are described more fully below. To
calculate either of these metrics requires a series of indexes.

A series of indexes is a collection of progressively longer indexes that
are estimated over time, or estimated sequentially such that the
knowledge of the future is withheld from the model. For example, imagine
we have, as the example below does, 84 months (periods) of data. Since
we are using a statistical modeling approach, let's assume that we need
at least 12 period of data (training period) to fit a model. We begin by
creating an index for periods 1 through 12, assuming that we only have
data from periods 1 through 12. Then we do 1 through 13, assuming we
only have data from periods 1 through 13; on up to period 84. This
represents an index series. The indexes in the series are identified by
the number of the last period that they are estimating, index 12, index
13, etc.

The \texttt{createSeries()} function will create these series. The
\texttt{hpi\_obj} argument must be a full \texttt{hpi} object (created
with one of the index wrappers). \texttt{train\_period} sets how many
periods to use for initial training (length of the shortest period). The
\texttt{max\_period} argument (default is the entire length of existing
index) will control the end period to estimate a series up to (defaults
to the original length of the index in the \texttt{hpi} object.).

The \texttt{createSeries()} function will return an object of class
\texttt{serieshpi} (data plus a series of \texttt{hpi} objects).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{   rt_series <-}\StringTok{ }\KeywordTok{createSeries}\NormalTok{(}\DataTypeTok{hpi_obj =}\NormalTok{ rt_hpi,}
                             \DataTypeTok{train_period =} \DecValTok{24}\NormalTok{,}
                             \DataTypeTok{max_period =} \DecValTok{30}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A series can be plotted with the \texttt{plot.serieshpi()} method.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{plot}\NormalTok{(rt_series)}
\end{Highlighting}
\end{Shaded}

\includegraphics{hpir_ares2019_files/figure-latex/plot_series-1.pdf}

\paragraph{Series Analysis}\label{series-analysis}

A wrapper function, \texttt{smoothSeries()} will smooth all
\texttt{hpiindex} objects in a series. The smoothing will occur ``in
place'' and a series object will be returned by the function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_series <-}\StringTok{ }\KeywordTok{smoothSeries}\NormalTok{(}\DataTypeTok{series_obj =}\NormalTok{ rt_series,}
                             \DataTypeTok{order =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A wrapper function, \texttt{calcSeriesVolatility()} will calculate
volatility for all \texttt{hpiindex} objects in a series. The
calculations will occur ``in place'' and a series object will be
returned by the function. Can be done on smoothed indexes as well
(\texttt{smooth\ =\ TRUE})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_series <-}\StringTok{ }\KeywordTok{calcSeriesVolatility}\NormalTok{(}\DataTypeTok{series_obj =}\NormalTok{ rt_series,}
                                    \DataTypeTok{window =} \DecValTok{3}\NormalTok{,}
                                    \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{)}
  
\end{Highlighting}
\end{Shaded}

A wrapper function, \texttt{calcSeriesAccuracy()} will calculate
accuracy for all \texttt{hpiindex} objects in a series and return to an
object of class \texttt{seriesaccuracy}. Smoothed indexes can be
evaluated as well (\texttt{smooth\ =\ TRUE})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_sacc <-}\StringTok{ }\KeywordTok{calcSeriesAccuracy}\NormalTok{(}\DataTypeTok{series_obj =}\NormalTok{ rt_series,}
                                \DataTypeTok{test_method =} \StringTok{'insample'}\NormalTok{,}
                                \DataTypeTok{test_type =} \StringTok{'rt'}\NormalTok{)}
  \KeywordTok{class}\NormalTok{(rt_sacc)}
\NormalTok{## [1] "seriesaccuracy" "hpiaccuracy"    "data.frame"}
\end{Highlighting}
\end{Shaded}

These calculations can occur ``in place'' and a series object will be
returned by the function. Note that running this function on the
``kfold'' method may be computationally intense depending on your data
size and index length. Unlike index accuracy calculations which are
saved in the \texttt{hpiindex} object, series accuracy calculations are
saved in the \texttt{serieshpi} object when done ``in place''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_series <-}\StringTok{ }\KeywordTok{calcSeriesAccuracy}\NormalTok{(}\DataTypeTok{series_obj =}\NormalTok{ rt_series,}
                                  \DataTypeTok{test_method =} \StringTok{'kfold'}\NormalTok{,}
                                  \DataTypeTok{test_type =} \StringTok{'rt'}\NormalTok{,}
                                  \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{,}
                                  \DataTypeTok{in_place=}\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

One thing to note about series accuracy is that the training data will
be evaluated separated for each index in the series, meaning that there
will be many prediction errors for each observation. By setting
\texttt{summarize\ =\ TRUE}, the mean for each observation will be
calculated.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  series_acc_summ <-}\StringTok{ }\KeywordTok{calcSeriesAccuracy}\NormalTok{(}\DataTypeTok{series_obj =}\NormalTok{ rt_series,}
                                        \DataTypeTok{test_method =} \StringTok{'insample'}\NormalTok{,}
                                        \DataTypeTok{test_type =} \StringTok{'rt'}\NormalTok{,}
                                        \DataTypeTok{summarize =} \OtherTok{TRUE}\NormalTok{)}
  \KeywordTok{nrow}\NormalTok{(series_acc_summ)}
\NormalTok{## [1] 35}
  \KeywordTok{nrow}\NormalTok{(rt_series}\OperatorTok{$}\NormalTok{accuracy)}
\NormalTok{## [1] 189}
\end{Highlighting}
\end{Shaded}

\paragraph{Forecast Accuracy}\label{forecast-accuracy}

A final way to estimate accuracy is with a forecast test. In a forecast
test, we use a series of indexes and continue to predict one period
ahead and measure how well the predicted index does against repeated
transactions in that period. In highly volatile or cyclical markets this
is the most representative method of the answering the question: ``how
well does this index represent the near future?''

As above, it can be used on the raw index values or the smoothed ones
(\texttt{smooth\ =\ TRUE}). The forecast accuracy tests are saved in the
\texttt{serieshpi} object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  rt_series <-}\StringTok{ }\KeywordTok{calcSeriesAccuracy}\NormalTok{(}\DataTypeTok{series_obj =}\NormalTok{ rt_series,}
                                  \DataTypeTok{test_method =} \StringTok{'forecast'}\NormalTok{,}
                                  \DataTypeTok{test_type =} \StringTok{'rt'}\NormalTok{,}
                                  \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{,}
                                  \DataTypeTok{in_place =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can plot the \texttt{seriesaccuracy} objects, which look nearly
identical to \texttt{hpiaccuracy} objects.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{plot}\NormalTok{(rt_series}\OperatorTok{$}\NormalTok{accuracy_smooth)}
\end{Highlighting}
\end{Shaded}

\includegraphics{hpir_ares2019_files/figure-latex/unnamed-chunk-1-1.pdf}

\paragraph{Revision}\label{revision}

As can be the case with house price indexes, the estimated index values
move considerably as new data (transactions) are accumulated over time.
We can measure the amount of this change, or `revision' over time as a
useful metric or property of the series or of the final index.

Within the literature on house price indexes there is no standard or
agreed upon metric to summarize revision. Here we do it two ways. First,
at the period level where we calculate the average revision (change from
period to period) for each period in the series of indexes. Obviously,
the earlier period have a larger sample size (though they do have more
time to be influenced by future transactions) than the latter periods
are and, as such, are likely to be less volatile.

The second calculation simply averages all revisions across all periods
to provide a single value of the average and median revision for the
index series.

\begin{Shaded}
\begin{Highlighting}[]

  \CommentTok{# Return to a revision object}
\NormalTok{  rt_rev <-}\StringTok{ }\KeywordTok{calcRevision}\NormalTok{(}\DataTypeTok{series_obj =}\NormalTok{ rt_series)}

  \CommentTok{# Return in place (with smooth)}
\NormalTok{  rt_series <-}\StringTok{ }\KeywordTok{calcRevision}\NormalTok{(}\DataTypeTok{series_obj =}\NormalTok{ rt_series,}
                            \DataTypeTok{in_place =} \OtherTok{TRUE}\NormalTok{,}
                            \DataTypeTok{smooth =} \OtherTok{TRUE}\NormalTok{)}
  \KeywordTok{names}\NormalTok{(rt_series)}
\NormalTok{## [1] "data"            "hpis"            "accuracy_smooth" "revision_smooth"}
\end{Highlighting}
\end{Shaded}

We can plot the revisions with the \texttt{plot.hpirevision()} method to
show the average revision by time period. The `measure argument (default
= \emph{``median''}) determines whether median or mean revisions will be
shown.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{plot}\NormalTok{(rt_rev, }\DataTypeTok{measure=}\StringTok{'median'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{hpir_ares2019_files/figure-latex/plot_rtrev-1.pdf}

More information on the class structures of the object created above can
be found in the ``Classes in hpiR'' vignette in this package.

\subsection{Part 2: Random Forest Method and its Relative
Performance}\label{part-2-random-forest-method-and-its-relative-performance}


\end{document}
