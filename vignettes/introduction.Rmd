---
title: "Introduction to the hpiR package"
author: "Andy Krause"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

### Introduction

This vignette provides an introduction to using the `hpiR` package for estimating house price indexes.  At the current time, this package (version 0.1.0) offers only two methods to estimate house price indexes -- repeat sales and hedonic price models.  Future versions will additional methodological options.  Additional information on this package's development can be found at [www.github.com/andykrause/hpiR](https://www.github.com/andykrause/hpiR)

```{r eval=TRUE, messages=FALSE, echo=FALSE}

  suppressMessages(suppressWarnings(library(hpiR)))
  suppressMessages(suppressWarnings(library(knitr)))

```

Begin by loading the`hpiR` packages (assuming that you've already downloaded it from CRAN or from: [www.github.com/andykrause/hpiR](https://www.github.com/andykrause/hpiR).

```{r eval=FALSE, messages=FALSE, echo=TRUE}
  
  library(hpiR)

```

### Data

This package provides a sample dataset to work with.  This dataset, `seattle_sales`, includes over 43,000 sales of single family homes and townhouses within the City of Seattle over the 2010 to 2016 time frame. The source of the data is the King County Assessor's office.^[ A small amount of data cleaning has gone into the creating the data, for more information on this process please contact the author. ]  The data is open and free to share.

The data can be loaded into an object with wrapping the `data(seattle_sales)` command with `get`.   

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sales <- get(data(seattle_sales))

```

<!-- A simple plot shows the location of these sales across the city. -->

<!-- ```{r eval=TRUE, messages=FALSE, echo=TRUE} -->

<!-- #  ggplot(sales) + geom_sf() -->

<!-- ``` -->

All of the potential models that we can create with this package require the date of sales to be converted to a numeric and relative time period.  Relative, relating to the base period which is assumed to be the first period in the transaction data.  

The `dateToPeriod` function will convert R date fields into relative time periods, based on a periodicity of choice.  The available options are **yearly**, **quarterly**, **monthly** or **weekly**, with **yearly** as the default.  In addition to the sales data.frame and the periodicity type, the `dateToPeriod` function also requires an input telling it which field in the data contains the transaction (sale) date (`date`).

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sales <- dateToPeriod(sales_df = sales,
                        date = 'sale_date',
                        periodicity = 'monthly')

```

The default specification of `dateToPeriod` will use the minimum and maximum dates in the `sales_df` object at the lower and upper date boundaries for the modeling and index creation that follow.  You can, however, custom set these dates using the `min_date` and `max_date` argument.  For examples, let's assume that we want to actually estimate an index that covers the entire sales period plus one month on either side (in this case from December 2009 to January 2017).  We add these dates as alternate minimums and maximums. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sales <- dateToPeriod(sales_df = sales,
                        date = 'sale_date',
                        periodicity = 'monthly',
                        min_date = as.Date('2009-12-01'),
                        max_date = as.Date('2017-01-01'))

```

If the dates that are provided as alternative minimums and maximums are within the range of sales dates in the `sales_df` object, there are two options to what can happen.  The first, and default, is that the minimums and maximums will be adjusted to be the actual minimum and maximum dates in the transactions.  A warning will let you know that this has happened. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sales <- dateToPeriod(sales_df = sales,
                        date = 'sale_date',
                        periodicity = 'monthly',
                        min_date = as.Date('2010-12-01'),
                        max_date = as.Date('2016-01-01'))

```

Alternatively, you can use the `min_date` and `max_date` parameters to clip your dataset to a particular time frame by setting the `adj_type` argument to *clip*, (the default is *move* which simply moves it to the min or max in the data as shown above.)

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sales_clipped <- dateToPeriod(sales_df = sales,
                                date = 'sale_date',
                                periodicity = 'monthly',
                                min_date = as.Date('2010-12-01'),
                                max_date = as.Date('2016-01-01'),
                                adj_type = 'clip')

```

For the sake of the remainder of this analysis, let's allow the defaults to set the time boundaries based on the data itself (we will use the `sales` object going forward).

We now have a dataset that includes a new field (**date_period**) indicate the period of each transaction.  Additional information on the full extend of the periods as well as their numeric and date values can be found in the `period_table` attribute of the new `rs` object data.frame; or accessed by:

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  head(attr(sales, 'period_table'))

```

### Sale-Resale Model

We start by creating an index using a sale-resale model, one of the most popular methods to create a house price index. 

First, we use the `rsCreateSales` function to convert the raw transaction data (the **sales** object) into a data.frame of repeat sale (properties that have sold multiple times in the 2010 to 2016 period.)
The `rsCreateSales` function requires a unique property id field as well as a unique sale id field and a field denoting the sale price.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  rs_sales <- rsCreateSales(sales_df = sales,
                            prop_id = 'pinx',
                            sale_id = 'sale_id',
                            price = 'sale_price')
                          
```

This function creates a data.frame with seven fields: the property id, the time period for the first sale and the second sale, the price for the two sales and the unique sale ids for both sales. 

```{r eval=TRUE, messages=FALSE, echo=FALSE}

  knitr::kable(head(rs_sales, 10))

```

Next, we use this data to estimate a repeat sales model.  In this simple example we will use the **base** estimator (a simple OLS) with a logged dependent variable.  More information on other options here are covered in the **Estimators** section below. 

The `hpiModel` function is an S3 method that will dispatch on the class of the `hpi_data` object that is passed to it, in this case that class is 'rs' signifying that the data is in **repeat-sales** format.  Again, we'll use a 'base' estimator here with a logged dependent variable.  The `hpiModel` function returns an object of class `hpiModel' that includes the full regression model results, extracted and cleaned coefficients as well as additional information on the approach. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}
                          
  rs_model <- hpiModel(hpi_data = rs_sales,
                       estimator = 'base',
                       log_dep = TRUE)

```

We can then convert those model results into an index with the `modelToIndex` function.  The output of this function is a time-series object (class 'ts') that provides an index value (base = 100) for each of the time periods estimated.  No smoothing is done at this time. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}
                     
  rs_index <- modelToIndex(rs_model)

```

A simple plot shows the results of this estimation

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  plot(rs_index)

```

A wrapper function, `rsIndex`, will do all of the above taking it from a raw data.frame of sales date through to the index creation and storing in an object of class 'hpi'.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

sea_rs_index <- rsIndex(sales_df = sales, 
                        date = 'sale_date', 
                        price = 'sale_price', 
                        sale_id = 'sale_id', 
                        prop_id = 'pinx',
                        estimator = 'base',
                        log_dep = TRUE,
                        periodicity = 'monthly') 
```

A plot method exists to cleanly plot 'hpi' objects so that the axes are labeled clearly.

```{r eval=TRUE, messages=FALSE, echo=TRUE}
                        
 plot(sea_rs_index)

```

### Hedonic Price Model

Another option for developing a house price index is to use a hedonic price model.  Similar to the repeat sales model presented above, this process can be done stepwise or through a single wrapper function (`hedIndex`).  We'll start with individual steps.

First, we create a set of hedonic model ready data with the `hedCreateSales` function.  Here we provide the raw sales, along with field names for the property id, the sale id, the price and date.  A periodicity (year, qtr, month or week) is also required.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  hed_sales <- hedCreateSales(sales_df = sales,
                              prop_id = 'pinx',
                              sale_id = 'sale_id',
                              price = 'sale_price',
                              date= 'sale_date',
                              periodicity = 'monthly')
                              
```

Next,we estimate the hedonic model.  There are two ways to specify the model.  First, you can provide the dependent variable and independent variable(s) directly, as in the example below. These will simply be combined as a basic linear formula.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  hed_model <- hpiModel(hpi_data = hed_sales,
                        estimator = 'base',
                        dep_var = 'price',
                        ind_var = c('tot_sf', 'beds', 'baths'),
                        log_dep = TRUE)

```

If you'd like more control over the model specification -- such as using interactions or categorical variables -- you can, instead, provide a fully formed model specification in the `hed_spec` argument. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  hed_model <- hpiModel(hpi_data = hed_sales,
                        estimator = 'base',
                        hed_spec = as.formula('log(price) ~ as.factor(baths) + tot_sf'),
                        log_dep = TRUE)

```

The output from `hpiModel` can be converted to an index with the `modelToIndex` function. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  hed_index <- modelToIndex(hed_model)

```

And, again, this can be plotted to shown the index.

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  plot(hed_index, col=2, lwd=2)

```

The `hedIndex` wrapper function will perform all of the above hedonic modeling tasks, and then condense the results into an object of class **hpi**.

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sea_hed_index <- hedIndex(sales_df = sales, 
                            date = 'sale_date', 
                            price = 'sale_price', 
                            sale_id = 'sale_id', 
                            prop_id = 'pinx',
                            estimator = 'base',
                            log_dep = TRUE,
                            periodicity = 'monthly',
                            dep_var = 'price',
                            ind_var = c('tot_sf', 'beds', 'baths'))

  plot(sea_hed_index)

```

### Analyzing an index

#### Volatility

One thing we can check for an index is its volatility.  We can get the a rolling windown volatility (standard deviation) of the index with the `calcIndexVolatility()` function.  The **window** over which to calculate the volatility can be specified.  Both volatility metrics at each window calculation (**roll**) as well as the summarized average volality(**mean**) are returned by the function.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

 index_vol <- calcIndexVolatility(index = rs_index$index, 
                                  window = 3)

  plot(index_vol)

```

#### Predictive Ability

Next, we can test the predictive ability of an index.  In this case, we will define predictive as the ability to properly predict the second sale price of a repeat sales pair (a property that sells twice).  To start, we'll do this in-sample, ignoring any issues of overfitting.

We begin by extracting the repeat sale data (which we'll use to test the indexes), as well as the two indexes from their larger `hpi` object developed above.

```{r eval=TRUE, messages=FALSE, echo=TRUE}

 # Extract Data
 rs_data <- sea_rs_index$data

 # Extract just the indexes
 index_rs <- sea_rs_index$index$index
 index_hed <- sea_hed_index$index$index
 
```

Then we test for the in-sample predictive ability of each with the `calcHPIError()` function.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

 # Repeat sales index
 rs_error <- calcHPIError(pred_data = rs_data,
                          index = index_rs)

 # Hedonic index
 hed_error <- calcHPIError(pred_data = rs_data,
                           index = index_hed)
 
  plot(hed_error)
  plot(rs_error)

```

We can then compare the summary statistics of the errors, which seem to suggest that the hedonic price modeling approach is slighly more accurate than the repeat sales model. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}
  
  error_df <- data.frame(rs = round(as.numeric(summary(abs(rs_error$pred_error))), 3),
                         hed = round(as.numeric(summary(abs(hed_error$pred_error))), 3))
  rownames(error_df) <- c("Min", '25th', 'Median', 'Mean', '75th', 'Max')
  knitr::kable(error_df)

```

The previous set of errors were, essentially, in-sample errors.  If we want to calculate out of sample errors with a k-fold holdout process we can use the `calcKFoldErrors()` function.  It takes as arguments any 'hpi' object, a set of data to do the predictions on (only repeat sales data - 'rs' object type - for now) and the number of folds to be used.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}
  
  hed_oos_errors <- calcKFoldErrors(hpi_obj = sea_hed_index,
                                    pred_data = rs_data,
                                    k = 10)

  rs_oos_errors <- calcKFoldErrors(hpi_obj = sea_rs_index,
                                   pred_data = rs_data,
                                   k = 10)

  plot(hed_oos_errors)
  plot(rs_oos_errors)
  
  
```

```{r eval=TRUE, messages=FALSE, echo=TRUE}
  
  error_df <- data.frame(rs = round(as.numeric(summary(abs(rs_error$pred_error))), 3),
                         rs_oos = round(as.numeric(summary(abs(rs_oos_errors$pred_error))), 3),
                         hed = round(as.numeric(summary(abs(hed_error$pred_error))), 3),
                        hed_oos = round(as.numeric(summary(abs(hed_oos_errors$pred_error))), 3))
  rownames(error_df) <- c("Min", '25th', 'Median', 'Mean', '75th', 'Max')
  knitr::kable(error_df)

```

Another way to examine predictive error is to approach the question through forecast (prediction out in time).  To do this, we built an index at each period (using only date up to that point in time) and then predict for the period t+1.  In this way, we create a series of indexes, each one time period longer than the next.  

Because this period of indexes is also useful for some other calculations, we have a separate function to create this series, 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  hed_series <- calcIndexSeries(hpi_obj = sea_hed_index,
                                train_range = 24)

  rs_series <- calcIndexSeries(hpi_obj = sea_rs_index,
                               train_range = 24)
  
  plot(hed_series)
  plot(rs_series)
  
```

From these series, we can then estimate the forecast (prediction) errors of for each of the two methods. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  hed_fc_errors <- calcForecastErrors(is_obj = hed_series,
                                      pred_data = rs_data)

  rs_fc_errors <- calcForecastErrors(is_obj = rs_series,
                                     pred_data = rs_data)
  
  plot(rs_fc_errors)
  plot(hed_fc_errors)

```

Comparing these errors to the previous we see, as expected, that the forecasting process creates higher errors than the k-fold process, through the differences are much larger in the repeat sales method. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}
  
  error_df <- data.frame(rs = round(as.numeric(summary(abs(rs_error$pred_error))), 3),
                         rs_oos = round(as.numeric(summary(abs(
                           rs_oos_errors$pred_error))), 3),
                         rs_fc = round(as.numeric(summary(abs(
                           rs_fc_errors$pred_error))), 3),
                         hed = round(as.numeric(summary(abs(hed_error$pred_error))), 3),
                         hed_oos = round(as.numeric(summary(abs(
                           hed_oos_errors$pred_error))), 3),
                         hed_fc = round(as.numeric(summary(abs(
                           hed_fc_errors$pred_error))), 3))

  rownames(error_df) <- c("Min", '25th', 'Median', 'Mean', '75th', 'Max')
  knitr::kable(error_df)

```

#### Revision

A third metric to consider when looking at house price indexes is revision, or how much previous estimates are revised each time a new period occurs and new data is added to the analysis.  

Within the literature there is no standard or agreed upon metric to summarize revision.  Here we do it two ways.  First, at the period level where we calculate the average revision (change from period to period) for each period in the series of indexes.  Obviously, the earlier period have a larger sample size that the latter periods are, as such, are likely to be less volatile.
The second calculation simply averages all revisions across all periods to provide a single value of the average revision for the index series.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  hed_rev <- calcRevision(hed_series)  
  rs_rev <- calcRevision(rs_series)
  
  plot(hed_rev)
  plot(rs_rev)
  
```

The hedonic revision has a total average value of 0.0003 index points per period, while the repeat sale revision averages -0.655 points per month, a considerable differnence. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  plot(rs_rev$period$revision, type='l')
  lines(hed_rev$period$revision, col=2)
  
```

### Estimators

* **base**
* **robust**
* **weighted**


### Blending and Smoothing Indexes

It may be advantageous to blend indexes.  We offer the `blendIndexes` function to do that.  Provide a list of indexes (of the same length), plus a set of weights that control the blending process.  If the **weights** argument is left blank, it will be blended evenly (1/n). Weights vector must be the same length as the index list. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  blend_index <- blendIndexes(index_list = list(rs_series[[61]],
                                                hed_series[[61]]),
                              weights=c(.6, .4))

  plot(blend_index)
  
```

Smoothing of indexes may also be warranted as indexes resulting from raw model results often exhibit greater volatility than is actually occuring in the market.  The `smooth_index` function will smooth via a moving average function, with small corrections to keep index length after smoothing.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  rs_smooth_index <- smoothIndex(rs_series[[61]], order = 5)
  hed_smooth_index <- smoothIndex(hed_series[[61]], order = 5)
  
  plot(rs_smooth_index)
  plot(hed_smooth_index)
  

```


