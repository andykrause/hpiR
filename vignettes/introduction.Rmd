---
title: "Introduction to the hpiR package"
author: "Andy Krause"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

### Introduction

This vignette provides an introduction to using the `hpiR` package for estimating house price indexes.  At the current time, this package (version 0.0.1) offers only two methods to estimate house price indexes -- repeat sales and hedonic price models.  Future versions will additional methodological options.  Additional information on this package's development can be found at [www.github.com/andykrause](https://www.github.com/andykrause)

```{r eval=TRUE, messages=FALSE, echo=FALSE}

  suppressMessages(suppressWarnings(library(hpiR)))
  suppressMessages(suppressWarnings(library(knitr)))

```

Begin by loading the`hpiR` packages (assuming that you've already downloaded it from CRAN or from: [www.github.com/andykrause/hpiR](https://www.github.com/andykrause/hpiR).

```{r eval=FALSE, messages=FALSE, echo=TRUE}
  
  library(hpiR)

```

### Data

This package provides a sample dataset to work with.  This dataset, `seattle_sales`, includes over 43,000 sales of single family homes and townhouses within the City of Seattle over the 2010 to 2016 time frame. The source of the data is the King County Assessor's office.^[ A small amount of data cleaning has gone into the creating the data, for more information on this process please contact the author. ]  The data is open and free to share.

The data can be loaded into an object with wrapping the `data(seattle_sales)` command with `get`.   

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sales <- get(data(seattle_sales))

```

A simple plot shows the location of these sales across the city.

```{r eval=TRUE, messages=FALSE, echo=TRUE}

#  ggplot(sales) + geom_sf()

```

All of the potential models that we can create with this package require the date of sales to be converted to a numeric and relative time period.  Relative, relating to the base period which is assumed to be the first period in the transaction data.  

The `dateToPeriod` function will convert R date fields into relative time periods, based on a periodicity of choice.  The available options are **year**, **qtr**, **month** or **week**, with **year** as the default.  In addition to the sales data.frame and the periodicity type, the `dateToPeriod` function also requires an input telling it which field in the data contains the transaction (sale) date (`date`).

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sales <- dateToPeriod(sales_df = sales,
                        date = 'sale_date',
                        periodicity = 'month')

```

The default specification of `dateToPeriod` will use the minimum and maximum dates in the `sales_df` object at the lower and upper date boundaries for the modeling and index creation that follow.  You can, however, custom set these dates using the `min_date` and `max_date` argument.  For examples, let's assume that we want to actually estimate an index that covers the entire sales period plus one month on either side (in this case from December 2009 to January 2017).  We add these dates as alternate minimums and maximums. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sales <- dateToPeriod(sales_df = sales,
                        date = 'sale_date',
                        periodicity = 'month',
                        min_date = as.Date('2009-12-01'),
                        max_date = as.Date('2017-01-01'))

```

If the dates that are provided as alternative minimums and maximums are within the range of sales dates in the `sales_df` object, there are two options to what can happen.  The first, and default, is that the minimums and maximums will be adjusted to be the actual minimum and maximum dates in the transactions.  A warning will let you know that this has happened. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sales <- dateToPeriod(sales_df = sales,
                        date = 'sale_date',
                        periodicity = 'month',
                        min_date = as.Date('2010-12-01'),
                        max_date = as.Date('2016-01-01'))

```

Alternatively, you can use the `min_date` and `max_date` parameters to clip your dataset to a particular time frame by setting the `adj_type` argument to *clip*, (the default is *move* which simply moves it to the min or max in the data as shown above.)

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sales_clipped <- dateToPeriod(sales_df = sales,
                                date = 'sale_date',
                                periodicity = 'month',
                                min_date = as.Date('2010-12-01'),
                                max_date = as.Date('2016-01-01'),
                                adj_type = 'clip')

```

For the sake of the remainder of this analysis, let's allow the defaults to set the time boundaries based on the data itself (we will use the `sales` object going forward).

We now have a dataset that includes a new field (**date_period**) indicate the period of each transaction.  Additional information on the full extend of the periods as well as their numeric and date values can be found in the `period_table` attribute of the new `rs` object data.frame; or accessed by:

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  attr(sales, 'period_table')

```

### Sale-Resale Model

We start by creating an index using a sale-resale model, one of the most popular methods to create a house price index. 

First, we use the `rsCreateSales` function to convert the raw transaction data (the **sales** object) into a data.frame of repeat sale (properties that have sold multiple times in the 2010 to 2016 period.)
The `rsCreateSales` function requires a unique property id field as well as a unique sale id field and a field denoting the sale price.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  rs_sales <- rsCreateSales(sales_df = sales,
                            prop_id = 'pinx',
                            sale_id = 'sale_id',
                            price = 'sale_price')
                          
```

This function creates a data.frame with seven fields: the property id, the time period for the first sale and the second sale, the price for the two sales and the unique sale ids for both sales. 

```{r eval=TRUE, messages=FALSE, echo=FALSE}

  knitr::kable(head(rs_sales, 10))

```

Next, we use this data to estimate a repeat sales model.  In this simple example we will use the **base** estimator (a simple OLS) with a logged dependent variable.  More information on other options here are covered in the **Estimators** section below. 

The `hpiModel` function is an S3 method that will dispatch on the class of the `hpi_data` object that is passed to it, in this case that class is 'rs' signifying that the data is in **repeat-sales** format.  Again, we'll use a 'base' estimator here with a logged dependent variable.  The `hpiModel` function returns an object of class `hpiModel' that includes the full regression model results, extracted and cleaned coefficients as well as additional information on the approach. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}
                          
  rs_model <- hpiModel(hpi_data = rs_sales,
                       estimator = 'base',
                       log_dep = TRUE)

```

We can then convert those model results into an index with the `modelToIndex` function.  The output of this function is a time-series object (class 'ts') that provides an index value (base = 100) for each of the time periods estimated.  No smoothing is done at this time. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}
                     
  rs_index <- modelToIndex(rs_model)

```

A simple plot shows the results of this estimation

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  plot(rs_index)

```

A wrapper function, `rsIndex`, will do all of the above taking it from a raw data.frame of sales date through to the index creation and storing in an object of class 'hpi'.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

sea_rs_index <- rsIndex(sales_df = sales, 
                        date = 'sale_date', 
                        price = 'sale_price', 
                        sale_id = 'sale_id', 
                        prop_id = 'pinx',
                        estimator = 'base',
                        log_dep = TRUE,
                        periodicity = 'month') 
```

A plot method exists to cleanly plot 'hpi' objects so that the axes are labeled clearly.

```{r eval=TRUE, messages=FALSE, echo=TRUE}
                        
 plot(sea_rs_index)

```

### Hedonic Price Model

Another option for developing a house price index is to use a hedonic price model.  Similar to the repeat sales model presented above, this process can be done stepwise or through a single wrapper function (`hedIndex`).  We'll start with individual steps.

First, we create a set of hedonic model ready data with the `hedCreateSales` function.  Here we provide the raw sales, along with field names for the property id, the sale id, the price and date.  A periodicity (year, qtr, month or week) is also required.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  hed_sales <- hedCreateSales(sales_df = sales,
                              prop_id = 'pinx',
                              sale_id = 'sale_id',
                              price = 'sale_price',
                              date= 'sale_date',
                              periodicity = 'month')
                              
```

Next,we estimate the hedonic model.  There are two ways to specify the model.  First, you can provide the dependent variable and independent variable(s) directly, as in the example below. These will simply be combined as a basic linear formula.  

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  hed_model <- hpiModel(hpi_data = hed_sales,
                        estimator = 'base',
                        dep_var = 'price',
                        ind_var = c('tot_sf', 'beds', 'baths'),
                        log_dep = TRUE)

```

If you'd like more control over the model specification -- such as using interactions or categorical variables -- you can, instead, provide a fully formed model specification in the `hed_spec` argument. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  hed_model <- hpiModel(hpi_data = hed_sales,
                        estimator = 'base',
                        hed_spec = as.formula('log(price) ~ as.factor(baths) + tot_sf'),
                        log_dep = TRUE)

```

The output from `hpiModel` can be converted to an index with the `modelToIndex` function. 

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  hed_index <- modelToIndex(hed_model)

```

And, again, this can be plotted to shown the index.

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  plot(hed_index, col=2, lwd=2)

```

The `hedIndex` wrapper function will perform all of the above hedonic modeling tasks, and then condense the results into an object of class **hpi**.

```{r eval=TRUE, messages=FALSE, echo=TRUE}

  sea_hed_index <- hedIndex(sales_df = sales, 
                            date = 'sale_date', 
                            price = 'sale_price', 
                            sale_id = 'sale_id', 
                            prop_id = 'pinx',
                            estimator = 'base',
                            log_dep = TRUE,
                            periodicity = 'month',
                            dep_var = 'price',
                            ind_var = c('tot_sf', 'beds', 'baths'))

```

### Estimators

* **base**
* **robust**
* **weighted**
